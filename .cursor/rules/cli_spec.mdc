---
description:
globs:
alwaysApply: true
---
# initFlow CLI Workflow Specification

**Version:** 1.0  
**Target Implementation:** Go CLI  
**Date:** September 2025

---

## Overview

This document specifies the complete CLI workflow for initFlow, covering user authentication, device registration, and workspace key initialization. The CLI implements a **zero-knowledge architecture** where the server never sees plaintext secrets or workspace keys.

## Table of Contents

1. [Authentication Flow](#authentication-flow)
2. [Device Registration](#device-registration)
3. [Workspace Key Initialization](#workspace-key-initialization)
4. [Cryptographic Implementation](#cryptographic-implementation)
5. [Error Handling](#error-handling)
6. [Security Considerations](#security-considerations)

---

## Authentication Flow

### CLI Command
```bash
initflow auth login <email>
# Interactive password prompt for security
```

### User Experience
```
$ initflow auth login user@example.com
Password: â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢
ğŸ” Authenticating...
âœ… Login successful! Registration token expires in 15 minutes.
ğŸ’¡ Next: Register this device with 'initflow device register <name>'
```

### HTTP Request
```http
POST /api/v1/auth/login
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "user_password"
}
```

### HTTP Response
```json
{
  "token": "eyJhbGciOiJIUzI1NiJ9...",
  "user": {
    "id": 123,
    "email": "user@example.com",
    "name": "John",
    "surname": "Doe"
  }
}
```

### CLI Implementation Notes
- **Token Storage**: Store the registration token securely (OS keychain/credential manager)
- **Token Expiry**: 15-minute expiration, warn user at 12 minutes
- **Password Security**: Never log or store passwords, use secure input methods

---

## Device Registration

### CLI Command
```bash
initflow device register "My MacBook CLI"
```

### User Experience
```
$ initflow device register "My MacBook CLI"
ğŸ”‘ Generating Ed25519 signing keypair...
ğŸ”’ Generating X25519 encryption keypair...
ğŸ“¡ Registering device with server...
âœ… Device registered successfully!

Device ID: abc123def456
Device Name: My MacBook CLI
Created: 2025-09-13 14:30:22 UTC

ğŸ” Keys stored securely in system keychain
ğŸ’¡ Next: Initialize workspace keys with 'initflow workspace list'
```

### Cryptographic Operations (Client-Side)

#### 1. Key Generation
```go
// Generate Ed25519 keypair for request signing
signingPublicKey, signingPrivateKey := ed25519.GenerateKey()

// Generate X25519 keypair for encryption
encryptionPublicKey, encryptionPrivateKey := generateX25519Keypair()
```

#### 2. Secure Storage
```go
// Store private keys in OS-specific secure storage
keychain.Store("initflow.signing.private", signingPrivateKey)
keychain.Store("initflow.encryption.private", encryptionPrivateKey)
keychain.Store("initflow.device.id", deviceID)
```

### HTTP Request
```http
POST /api/v1/devices
Content-Type: application/json

{
  "token": "eyJhbGciOiJIUzI1NiJ9...",
  "name": "My MacBook CLI",
  "public_key_ed25519": "base64-encoded-ed25519-public-key",
  "public_key_x25519": "base64-encoded-x25519-public-key"
}
```

### HTTP Response
```json
{
  "success": true,
  "message": "Device registered successfully",
  "device": {
    "device_id": "abc123def456",
    "name": "My MacBook CLI",
    "created_at": "2025-09-13T14:30:22Z"
  }
}
```

### CLI Implementation Notes
- **Key Storage**: Use OS keychain (macOS), Windows Credential Manager, or Linux Secret Service
- **Key Format**: Store keys in binary format, encode as base64 for API transmission
- **Device ID**: Store device ID for future authenticated requests
- **Cleanup**: Delete registration token after successful device registration

---

## Workspace Key Initialization

### CLI Command
```bash
# List workspaces first
initflow workspace list

# Initialize key for specific workspace
initflow workspace init-key <workspace-slug>
```

### User Experience

#### Listing Workspaces
```
$ initflow workspace list
ğŸ” Fetching workspaces...

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ Name            â”‚ Slug           â”‚ Key Initialized â”‚ Role â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚ My Project      â”‚ my-project     â”‚ âŒ No          â”‚ Ownerâ”‚
â”‚ Team Secrets    â”‚ team-secrets   â”‚ âœ… Yes         â”‚ Memberâ”‚
â”‚ Personal Vault  â”‚ personal-vault â”‚ âŒ No          â”‚ Ownerâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜

ğŸ’¡ Initialize keys for workspaces marked "No" using:
   initflow workspace init-key <workspace-slug>
```

#### Key Initialization
```
$ initflow workspace init-key my-project
ğŸ” Initializing workspace key for "My Project"...

âš¡ Generating secure 256-bit workspace key...
ğŸ”’ Encrypting with your device's X25519 key...
ğŸ“¡ Uploading encrypted key to server...

âœ… Workspace key initialized successfully!
ğŸ¯ You can now store and retrieve secrets in this workspace.

Next steps:
  â€¢ Add secrets: initflow secrets add API_KEY=your-secret
  â€¢ List secrets: initflow secrets list
  â€¢ Invite devices: initflow workspace invite-device
```

### Cryptographic Operations (Client-Side)

#### 1. Workspace Key Generation
```go
// Generate random 256-bit workspace key
workspaceKey := make([]byte, 32)
rand.Read(workspaceKey)
```

#### 2. Key Wrapping with X25519
```go
// Load device's X25519 private key
encryptionPrivateKey := keychain.Load("initflow.encryption.private")

// Create shared secret for encryption (self-encryption pattern)
// In practice, this would use a more sophisticated key derivation
sharedSecret := x25519.X25519(encryptionPrivateKey, devicePublicKey)

// Encrypt workspace key using ChaCha20-Poly1305
cipher := chacha20poly1305.New(sharedSecret[:32])
nonce := make([]byte, 12)
rand.Read(nonce)
wrappedKey := cipher.Seal(nonce, nonce, workspaceKey, nil)
```

#### 3. Local Storage
```go
// Store workspace key locally for future secret operations
keychain.Store(fmt.Sprintf("initflow.workspace.%s", workspaceSlug), workspaceKey)
```

### HTTP Requests

#### List Workspaces
```http
GET /api/v1/workspaces
Authorization: Device abc123def456
X-Signature: base64-encoded-ed25519-signature
X-Timestamp: 1694612345
```

**Request Signing Process:**
```go
// Build signature message
message := fmt.Sprintf("%s\n%s\n%s\n%d", 
    method,           // "GET"
    path,             // "/api/v1/workspaces"  
    body,             // "" (empty for GET)
    timestamp)        // 1694612345

// Sign with Ed25519 private key
signature := ed25519.Sign(signingPrivateKey, []byte(message))

// Encode signature for header
encodedSignature := base64.StdEncoding.EncodeToString(signature)
```

#### Initialize Workspace Key
```http
POST /api/v1/workspaces/123/initialize
Authorization: Device abc123def456
X-Signature: base64-encoded-ed25519-signature
X-Timestamp: 1694612345
Content-Type: application/json

{
  "wrapped_workspace_key": "base64-encoded-encrypted-workspace-key"
}
```

### HTTP Responses

#### List Workspaces Response
```json
{
  "workspaces": [
    {
      "id": 123,
      "name": "My Project",
      "slug": "my-project",
      "description": "Project secrets and API keys",
      "key_initialized": false,
      "key_version": 0,
      "organization": {
        "id": 456,
        "name": "John Doe's Personal Account",
        "slug": "john-doe"
      }
    },
    {
      "id": 124,
      "name": "Team Secrets", 
      "slug": "team-secrets",
      "description": "Shared team credentials",
      "key_initialized": true,
      "key_version": 1,
      "organization": {
        "id": 789,
        "name": "Acme Corp",
        "slug": "acme-corp"
      }
    }
  ]
}
```

#### Initialize Key Response
```json
{
  "success": true,
  "message": "Workspace key initialized successfully",
  "workspace": {
    "id": 123,
    "name": "My Project",
    "slug": "my-project", 
    "key_initialized": true,
    "key_version": 1
  }
}
```

---

## Cryptographic Implementation

### Key Types and Purposes

| Key Type | Purpose | Algorithm | Size | Storage |
|----------|---------|-----------|------|---------|
| **Signing Private Key** | Request authentication | Ed25519 | 32 bytes | OS Keychain |
| **Signing Public Key** | Request verification | Ed25519 | 32 bytes | Server DB |
| **Encryption Private Key** | Key wrapping/unwrapping | X25519 | 32 bytes | OS Keychain |
| **Encryption Public Key** | Key wrapping | X25519 | 32 bytes | Server DB |
| **Workspace Key** | Secret encryption | ChaCha20-Poly1305 | 32 bytes | OS Keychain |

### Request Signing Protocol

All authenticated API requests must be signed using the device's Ed25519 private key.

#### Signature Message Format
```
{HTTP_METHOD}\n{REQUEST_PATH}{QUERY_STRING}\n{REQUEST_BODY}\n{TIMESTAMP}
```

#### Example Signature Message
```
POST
/api/v1/workspaces/123/initialize
{"wrapped_workspace_key":"eyJhbGciOiJIUzI1NiJ9..."}
1694612345
```

#### Headers Required
- `Authorization: Device {device_id}`
- `X-Signature: {base64_encoded_signature}`
- `X-Timestamp: {unix_timestamp}`

### Key Wrapping Protocol

Workspace keys are encrypted using X25519 Elliptic Curve Diffie-Hellman with ChaCha20-Poly1305.

#### Wrapping Process
1. Generate ephemeral X25519 keypair
2. Compute shared secret: `shared = X25519(ephemeral_private, device_public)`
3. Derive encryption key: `key = HKDF(shared, salt="initflow.wrap", info="workspace")`
4. Encrypt: `wrapped = ChaCha20Poly1305.Encrypt(key, workspace_key, nonce)`
5. Package: `ephemeral_public || nonce || wrapped`

#### Unwrapping Process
1. Extract components: `ephemeral_public, nonce, wrapped = unpackage(wrapped_key)`
2. Compute shared secret: `shared = X25519(device_private, ephemeral_public)`
3. Derive encryption key: `key = HKDF(shared, salt="initflow.wrap", info="workspace")`
4. Decrypt: `workspace_key = ChaCha20Poly1305.Decrypt(key, wrapped, nonce)`

---

## Error Handling

### Authentication Errors

| Error | HTTP Status | CLI Response |
|-------|-------------|--------------|
| Invalid credentials | 401 | `âŒ Invalid email or password` |
| Missing fields | 400 | `âŒ Email and password required` |
| Rate limiting | 429 | `â° Too many attempts. Try again in 5 minutes` |

### Device Registration Errors

| Error | HTTP Status | CLI Response |
|-------|-------------|--------------|
| Invalid token | 401 | `âŒ Registration token expired. Please login again` |
| Invalid key format | 400 | `âŒ Invalid cryptographic key format` |
| Device name too long | 422 | `âŒ Device name must be 100 characters or less` |
| Network error | - | `ğŸŒ Network error. Check connection and retry` |

### Workspace Key Errors

| Error | HTTP Status | CLI Response |
|-------|-------------|--------------|
| Workspace not found | 404 | `âŒ Workspace 'my-project' not found` |
| Not workspace owner | 403 | `âŒ Only workspace owners can initialize keys` |
| Key already initialized | 409 | `â„¹ï¸ Workspace key already initialized` |
| Invalid signature | 401 | `âŒ Authentication failed. Re-register device` |

---

## Security Considerations

### Zero-Knowledge Architecture
- **Server never sees**: Plaintext passwords, workspace keys, or secret values
- **Server only stores**: Hashed passwords, wrapped keys, encrypted secrets
- **Client responsibility**: Key generation, encryption, secure storage

### Threat Model Protection

| Threat | Mitigation |
|--------|------------|
| **Server compromise** | Encrypted secrets, wrapped keys useless without device private keys |
| **Network interception** | All requests signed, sensitive data encrypted |
| **Device theft** | Private keys protected by OS keychain, biometric/PIN access |
| **Replay attacks** | Timestamp validation (5-minute window) |
| **Key rotation** | Versioned workspace keys, gradual migration support |

### Implementation Requirements

#### Go CLI Security Checklist
- [ ] Use `crypto/rand` for all random number generation
- [ ] Implement secure memory clearing for sensitive data
- [ ] Use OS-specific keychain libraries (keyring, wincred, etc.)
- [ ] Validate all server certificates (pin public keys in production)
- [ ] Implement proper error handling without information leakage
- [ ] Use constant-time comparisons for cryptographic operations
- [ ] Clear sensitive variables from memory after use
- [ ] Implement secure logging (never log keys or secrets)

#### Recommended Go Libraries
```go
// Cryptography
"crypto/ed25519"           // Ed25519 signatures
"golang.org/x/crypto/curve25519"  // X25519 key exchange
"golang.org/x/crypto/chacha20poly1305"  // Authenticated encryption

// Secure Storage  
"github.com/zalando/go-keyring"  // Cross-platform keychain
"github.com/99designs/keyring"   // Alternative keychain library

// HTTP Client
"net/http"                 // Standard HTTP client
"crypto/tls"              // TLS configuration
```

---

## API Endpoint Summary

| Endpoint | Method | Auth | Purpose |
|----------|--------|------|---------|
| `/api/v1/auth/login` | POST | None | User authentication |
| `/api/v1/devices` | POST | Token | Device registration |
| `/api/v1/workspaces` | GET | Device | List workspaces |
| `/api/v1/workspaces/{id}/initialize` | POST | Device | Initialize workspace key |

---

## Next Steps

This specification covers the foundational workflow. Future iterations should include:

1. **Secret Management**: `initflow secrets add/list/get/delete`
2. **Device Management**: `initflow device list/revoke`
3. **Workspace Sharing**: `initflow workspace invite/share`
4. **Key Rotation**: `initflow workspace rotate-key`
5. **Backup/Recovery**: `initflow backup create/restore`

---

**End of Specification**

*This document serves as the authoritative specification for implementing the initFlow CLI in Go. All cryptographic operations must be implemented exactly as specified to ensure compatibility with the Phoenix backend.*

